package main

import (
	"bytes"
	"errors"
	"fmt"
	"io/fs"
	"log"
	"os"
	"time"
)

type ownerChangeError struct {
	Path           string
	Owner, Current string
}

func (e *ownerChangeError) Error() string {
	return fmt.Sprintf("detected a change of ownership of %s. In multiple replica setups this can lead to un-needed rebalancing or bugs if there are multiple writers: owner=%q current=%q", e.Path, e.Owner, e.Current)
}

// ownerChecker can write and check the owner file for a index directory. It
// is used for detecting when multiple zoekts are writing to a directory, or
// when the ownership is changing too often.
//
// The motivation for this is a person can misconfigure zoekt such that
// multiple indexservers write to the same directory. This will lead to index
// thrashing and hard to debug errors. Alternatively if the stable identity
// (hostname) changes, this can lead to Sourcegraph's repo <-> owner hash
// changing which means unnecessary rebalancing.
type ownerChecker struct {
	Path     string
	Hostname string
}

// Run will regularly init then regularly check if we are owner. If an error
// is detected it will exit the current process with exit code 1. This method
// blocks.
func (o *ownerChecker) Run() {
	if err := o.Init(); err != nil {
		log.Fatal(err)
	}
	for {
		time.Sleep(5 * time.Second)
		if err := o.Check(); err != nil {
			log.Fatal(err)
		}
	}
}

func (o *ownerChecker) Init() error {
	var ownerErr *ownerChangeError
	if err := o.Check(); errors.Is(err, fs.ErrNotExist) {
		// do nothing, first run so we just write out the file
	} else if errors.As(err, &ownerErr) {
		debug.Printf("WARN: detected a change in ownership at startup. You can ignore this if you only have one zoekt replica: %s", err)
	} else if err != nil {
		return err
	}

	content := []byte(fmt.Sprintf(`DO NOT EDIT! generated by zoekt-sourcegraph-indexserver.
This file records the identity of the owner of this zoekt index directory.
If it changes, zoekt-sourcegraph-indexserver will exit with a non-zero exit code.
This is to prevent multiple owners/writers.

hostname=%s
`, o.Hostname))

	// Always write out since we may update the comment
	if err := os.WriteFile(o.Path, content, 0o600); err != nil {
		return fmt.Errorf("failed to write owner file %s: %w", o.Path, err)
	}

	return nil
}

func (o *ownerChecker) Check() error {
	if b, err := os.ReadFile(o.Path); err != nil {
		return fmt.Errorf("failed to read in owner file %s: %w", o.Path, err)
	} else if owner := bestEffortParseOwner(b); o.Hostname != owner {
		return &ownerChangeError{
			Path:    o.Path,
			Owner:   owner,
			Current: o.Hostname,
		}
	}
	return nil
}

func bestEffortParseOwner(b []byte) string {
	prefix := []byte("hostname=")
	from := bytes.Index(b, prefix)
	if from < 0 {
		return "UNKNOWN"
	}

	b = b[from+len(prefix):]
	if to := bytes.IndexByte(b, '\n'); to > 0 {
		b = b[:to]
	}

	return string(bytes.TrimSpace(b))
}
